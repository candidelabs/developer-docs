---
title: Passkeys Guide and Reference for Authenticating Safe Smart Accounts using abstractionkit
description: Utilize Passkeys for securing and backing up user Safe smart accounts through biometric authentication.
keywords: [passkeys, webauthn, safe, plugin]
image: /img/posters/passkeys_poster.png
---
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# How to Add Support for Passkeys Authentication

Passkeys secure on-chain smart accounts using **fingerprint**, **face recognition**, or device **PIN** codes. Users no longer need to manage complex private keys—they can access their digital wallets using passkey-enabled devices synced via Apple's **iCloud Keychain** or cross-platform password managers like **Proton Pass** and **Bitwarden**.

In Ethereum wallets, **Passkeys** replace traditional seed phrase backups. Unlike the secp256k1 curve used for Externally Owned Accounts (EOAs), Passkeys generate digital keys using the **secp256r1** curve. These keys leverage device secure enclave cryptography, enhancing security and preventing password reuse. Passkeys are built on the WebAuthn standard using public-key cryptography, developed collaboratively by the FIDO Alliance (Apple, Google, Microsoft, and others) in strict adherence to WebAuthn standards.

## Safe Passkeys

Safe Passkeys contracts are developed by the Safe Protocol Team.
The contracts and audits are available in the [Safe-Modules repository](https://github.com/safe-global/safe-modules/tree/main/modules/passkey).
Deployment addresses can be found on our [contract deployment](/wallet/technical-reference/deployments/#safe-passkeys) page.

## Demo
These examples showcase Safe Smart Account deployments utilizing ERC-4337 and Passkeys

- **React Demo**:
    - [Live Demo](https://passkeys.candide.dev/) 
    - [Source Code](https://github.com/candidelabs/safe-passkeys-react-example)

- **React Native Demo**
   - [Source Code](https://github.com/candidelabs/passkeys-react-native-demo)

- **Node.js demo with simulated Passkeys**
    - [Source Code](https://github.com/candidelabs/abstractionkit-examples/tree/main/passkeys)

## Quick start
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Xh7ZJ3oeOu8?si=UUARp_pt_cjebiop" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Create Passkeys Account

<Tabs>
<TabItem value="npm" label="npm">

```bash
npm i abstractionkit ox
```

</TabItem>
<TabItem value="yarn" label="yarn">

```bash
yarn add abstractionkit ox
```

</TabItem>
</Tabs>

### Step 1: Create WebAuthn Credentials

Create WebAuthn credentials using the `createCredential` function from `ox/WebAuthnP256`. This function simplifies credential creation by handling browser WebAuthn API interactions.

```ts
import { createCredential } from 'ox/WebAuthnP256'

const passkeyCredential = await createCredential({
    name: 'Safe Wallet',
    challenge: crypto.getRandomValues(new Uint8Array(32)),
    rp: {
      id: window.location.hostname,
      name: 'Safe Wallet'
    },
    authenticatorSelection: {
      authenticatorAttachment: 'platform',
      residentKey: 'required',
      userVerification: 'required',
    },
    timeout: 60000,
    attestation: 'none',
})
```

### Step 2: Extract Public Key

The `createCredential` function directly returns the public key coordinates, so no extra extraction step is needed.

```ts
import { WebauthPublicKey } from "abstractionkit";

const webauthPublicKey: WebauthPublicKey = {
    x: passkeyCredential.publicKey.x,
    y: passkeyCredential.publicKey.y,
}
```

### Step 3: Initialize Smart Account

Initialize the Safe Smart Account as usual. The `SafeAccountV0_3_0` supports Entrypoint v0.7, while `SafeAccountV0_2_0` supports Entrypoint v0.6.

```ts
import { SafeAccountV0_3_0 as SafeAccount } from "abstractionkit";

const smartAccount = SafeAccount.initializeNewAccount([webauthPublicKey])
```

## Create Passkey UserOp
This step follows the same flow as the standard Safe flow with [createUserOperation](../../abstractionkit/safe-account-v3/#createuseroperation), with the addition of the `expectedSigners` override.

```ts

let userOperation = await smartAccount.createUserOperation(
    [transaction] // construct your MetaTransaction 
    jsonRpcNodeProvider, //The Node rpc endpoint.
    bundlerUrl, //The Bundler rpc endpoint.
    // highlight-start
    {
        expectedSigners: [webauthPublicKey]
    },
    // highlight-end
)
```

## Sign with Passkeys

### Step 1: Calculate the EIP712 hash

Calculate the Safe EIP712 hash for the UserOp.

```ts
const userOpHash = SafeAccount.getUserOperationEip712Hash(
    userOperation,
    BigInt(chainId),
);
```

### Step 2: Request a WebAuthn Assertion

Use the `sign` function from `ox/WebAuthnP256` to sign the user operation hash.
This function accepts the `challenge` (user operation hash) and the passkey's `credentialId`.

```ts
import { sign } from 'ox/WebAuthnP256';
import { Hex as OxHex } from 'ox/Hex';
import { Bytes, Hex } from 'ox';

const { metadata, signature } = await sign({
    challenge: userOpHash as OxHex,
    credentialId: passkeyCredential.id as OxHex,
});
```

### Step 3: Create the `WebauthnSignatureData`

The `sign` function returns the `metadata` and `signature` needed to construct the `WebauthnSignatureData` object for `abstractionkit`.

```ts
import { WebauthnSignatureData } from "abstractionkit";

const clientDataMatch = metadata.clientDataJSON.match(
    /^\{"type":"webauthn.get","challenge":"[A-Za-z0-9\-_]{43}",(.*)\}$/,
);
if (!clientDataMatch) {
    throw new Error('Invalid clientDataJSON format: challenge not found');
}
const [, fields] = clientDataMatch;

const webauthnSignatureData: WebauthnSignatureData = {
    authenticatorData: Bytes.fromHex(metadata.authenticatorData).buffer as ArrayBuffer,
    clientDataFields: Hex.fromString(fields),
    rs: [signature.r, signature.s],
};

const webauthnSignature: string = SafeAccount.createWebAuthnSignature(webauthnSignatureData)
```

### Step 4: Create and Format Signer Signature Pair

Create a `SignerSignaturePair` containing the `webauthPublicKey` and `webauthSignature`, then format it into the expected userOperation signature format.

```ts
import { SignerSignaturePair } from "abstractionkit";

const signerSignaturePair: SignerSignaturePair = {
    signer: webauthPublicKey,
    signature: webauthnSignature,
}

userOperation.signature = SafeAccount.formatSignaturesToUseroperationSignature(
    [signerSignaturePair],
	{ isInit: userOperation.nonce == 0n },
)
```

## Submit the UserOp onchain

```ts
const sendUserOperationResponse = await smartAccount.sendUserOperation(
    userOperation,
    bundlerUrl,
);
const userOperationReceiptResult = await sendUserOperationResponse.included();
```


## Advanced

### Multisig

#### New Account
To initialize a smart account with multiple signer types, provide both a WebAuthn public key and an EOA public key to the initialization function, with the WebAuthn public key listed first.
To add two Passkey signers, initialize and deploy the account with a single Passkey signer first, then use [`addOwnerWithThreshold`](/wallet/abstractionkit/safe-account-v3/#createaddownerwiththresholdmetatransactions) to add the second Passkey signer.

```ts
import { SafeAccountV0_3_0 as SafeAccount } from "abstractionkit";
import { Wallet } from 'ethers'

const webauthPublicKey = .. // see above

// EOA Signer
const eoaSigner = Wallet.createRandom();
const eoaPublicKey = eoaSigner.address;

let smartAccount = SafeAccount.initializeNewAccount(
    // highlight-start
    [webauthPublicKey, eoaPublicKey],
    { threshold: 2 } 
    // highlight-end
)
```

#### Existing account

- Add a Passkeys owner to an existing account using [`createAddOwnerWithThresholdMetaTransactions`](/wallet/abstractionkit/safe-account-v3/#createaddownerwiththresholdmetatransactions)

```ts
import { MetaTransaction } from "abstractionkit"

const addPasskeysOwner: MetaTransaction = await smartAccount.createAddOwnerWithThresholdMetaTransactions(
    webauthPublicKey, // the x and y webAuthn publickey
    1, // threshold
    { nodeRpcUrl: nodeUrl }
);
```

- Swap an existing owner to a Passkeys owner using [`createSwapOwnerMetaTransactions`](/wallet/abstractionkit/safe-account-v3/#createswapownermetatransactions)

```ts
import { MetaTransaction } from "abstractionkit"

const swapOwnerWithPasskeys: MetaTransaction = await smartAccount.createSwapOwnerMetaTransactions(
    nodeUrl, 
    webauthPublicKey, // the x and y webAuthn publickey
    oldOwnerPublicKey, // the old owner to replace
);
```

#### Create UserOp

To obtain accurate gas estimates, pass the expected signers who will sign the UserOperation in the `createUserOperation` overrides.

```ts
let userOperation = await smartAccount.createUserOperation(
    [metaTransaction],
    jsonRpcNodeProvider, 
    bundlerUrl, 
    {
       // highlight-start
       expectedSigners:[webauthPublicKey, eoaPublicKey],
       // highlight-end
    }
)
```

#### Signature

To sign a transaction with multiple signers, pass the signer signature pairs to `formatSignaturesToUseroperationSignature`.

```ts
const eoaSignature = eoaSigner.signingKey.sign(userOpHash).serialized;
const eoaSignerSignaturePair: SignerSignaturePair = {
    signer: eoaPublicKey,
    signature: eoaSignature,
}

userOperation.signature = SafeAccount.formatSignaturesToUseroperationSignature(
    // highlight-start
    [webAuthnSignerSignaturePair, eoaSignerSignaturePair],
    // highlight-end
    { isInit: userOperation.nonce == 0n }
);
```

### Gas Savings with Precompiles

Leverage Native Passkeys with [RIP-7212](https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md) when supported for optimal gas efficiency. Import the default precompile address and pass it in the overrides.
Verify that your chain has adopted the same precompile address specified in the standard. 

#### New Account

```ts
import { SafeAccountV0_3_0 as SafeAccount, DEFAULT_SECP256R1_PRECOMPILE_ADDRESS } from "abstractionkit";

let smartAccount = SafeAccount.initializeNewAccount(
    [webauthPublicKey],
    // highlight-start
    { eip7212WebAuthnPrecompileVerifierForSharedSigner: DEFAULT_SECP256R1_PRECOMPILE_ADDRESS } 
    // highlight-end
)
```

#### Create UserOp

```ts
let userOperation = await smartAccount.createUserOperation(
    [metaTransaction],
    nodeRPC,
    bundlerURL,
    {
        expectedSigners:[webauthPublicKey],
        // highlight-start
        eip7212WebAuthnPrecompileVerifier: DEFAULT_SECP256R1_PRECOMPILE_ADDRESS
        // highlight-end
    }
);
```

#### Signature

```ts
userOperation.signature = SafeAccount.formatSignaturesToUseroperationSignature(
    [webauthnSignerSignaturePair],
    {
        isInit: userOperation.nonce == 0n,
        // highlight-start
        eip7212WebAuthnPrecompileVerifier: DEFAULT_SECP256R1_PRECOMPILE_ADDRESS,
        // highlight-end
    }
);
```

### Verifying a WebAuthn Signature
Validate WebAuthn signatures to verify whether a signature on behalf of a given Safe Account is valid, similar to EOA owner verification.

- Sign a message hash using the standard process:

```ts
import { hashMessage } from "ethers";

// highlight-start
const messageHashed = hashMessage("Hello World");
// highlight-end

const assertion = navigator.credentials.get({
  publicKey: {
    // highlight-start
    challenge: ethers.getBytes(messageHashed),
    // highlight-end
    rpId: "candide.dev",
    allowCredentials: [
    { type: "public-key", id: new Uint8Array(credential.rawId) },
    ],
    userVerification: UserVerificationRequirement.required,
  },
});

const webauthSignatureData: WebauthnSignatureData = {
    authenticatorData: assertion.response.authenticatorData,
    clientDataFields: extractClientDataFields(assertion.response),
    rs: extractSignature(assertion.response),
};

const webauthnSignature: string = SafeAccount.createWebAuthnSignature(webauthSignatureData);
```

- Validating a signed webAuthn message [`verifyWebAuthnSignatureForMessageHashParam`](/wallet/abstractionkit/safe-account-v3/#verifywebauthnsignatureformessagehash)

```ts
const isSignatureValid: boolean =
    await SafeAccount.verifyWebAuthnSignatureForMessageHash(
        nodeURL, // node url from a json rpc provider 
        webauthPublicKey, // the x and y webAuthn publickey 
        messageHashed,  
        webauthnSignature 
    );
```

For a complete example to sign and verify message, run the repo [safe-passkeys-sign-and-verify-message](https://github.com/Sednaoui/safe-passkeys-sign-and-verify-message)

## Additional Notes

### WebAuthn / Passkeys API

The WebAuthn API is a web standard that enables passwordless authentication, allowing users to sign in to websites and applications using biometric factors (e.g., fingerprint, face recognition) or security keys. 
This API is supported by most major browsers, including Google Chrome, Mozilla Firefox, Microsoft Edge, Apple Safari, Brave, and Opera. For more information 
on the browser support and requirements, Mozilla has created great [documentation on WebAuthn](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API).

#### Web-based:
In this guide, we use the `0x` library, which provides a high-level abstraction over the WebAuthn API. This simplifies the integration process by handling the low-level details of the WebAuthn API.

- **`ox/WebAuthnP256`**: This is the specific module from the `0x` library used in this guide. It provides functions for creating and using P-256 credentials, which are the standard for passkeys.

#### React Native:
For React Native applications, teams have used the following libraries to integrate the WebAuthn/Passkeys functionality:

- [**react-native-passkey**](https://www.npmjs.com/package/react-native-passkey): This library provides a React Native wrapper around the platform-specific WebAuthn/Passkeys APIs.
- [**cbor-web**](https://www.npmjs.com/package/cbor-web): This library is used in conjunction with `react-native-passkey` to handle the CBOR (Concise Binary Object Representation) data format used by the WebAuthn API.
  - [**React Native demo**](https://github.com/candidelabs/passkeys-react-native-demo) by Adrian, the lead developer from Unit-e, using `abstractionkit`, `react-native-passkey`, and `cbor-web`.

### Security Considerations
Consider implementing a [multisig setup](#multisig) or the [recovery module](/wallet/plugins/recovery-with-guardians/) when using Passkeys.
This demo demonstrates a simple setup with a 1/1 Safe using a passkey as the sole signer.
While straightforward, this approach is unsuitable for production environments.
Passkeys are tied to specific domain names and, in some cases, to particular hardware manufacturers. This dependency introduces vulnerabilities that could make user accounts inaccessible under certain circumstances:

1. **Device Migration**: Users switching between ecosystems (iPhone to Android, Windows to macOS, etc.) may lose access if the Passkey is device or ecosystem-specific.
2. **Domain Issues**: Compromised, unavailable, or unmaintained domains can cause Passkey authentication failures.

**Our recommendation**: Include at least a second access method for Safe accounts—either a different backup signer (1/2 Safe configuration) or a recovery method via the recovery module.

### Saving Public Credentials
Store Passkey public credentials (*x*, *y*, and *rawId*) in a retrievable location. Losing this data prevents users from recovering their accounts with Passkeys. This information isn't sensitive, you can use a simple server or leverage [@simplewebauthn/server](https://simplewebauthn.dev/docs/packages/server) for storage.

### Sync & Recovery

#### Apple
Passkey recovery on Apple devices uses iCloud Keychain escrow. In case of device loss, users authenticate through their iCloud account using standard procedures, then enter their device passcode. Apple users can also add an account recovery contact for additional support. Learn more about [Apple Passkeys security](https://support.apple.com/en-us/102195).

#### Google

Google Password Manager seamlessly syncs passkeys across devices, with plans to extend syncing support to additional operating systems. Learn more about [Google Passkeys security](https://developers.google.com/identity/passkeys).

#### YubiKey
YubiKey supports passkeys through its authentication protocol implementation.
Passkeys can be protected and managed using YubiKey's hardware-based security features.
Learn more at [Yubico](https://www.yubico.com/blog/a-yubico-faq-about-passkeys/).

#### Password Managers
Passkey backups extend beyond hardware manufacturers—they're supported across various password managers including [Windows Hello](https://support.microsoft.com/en-us/windows/passkeys-in-windows-301c8944-5ea2-452b-9886-97e4d2ef4422), [Bitwarden](https://bitwarden.com/passwordless-passkeys/), [Proton Pass](https://proton.me/blog/proton-pass-passkeys), [1Password](https://1password.com/product/passkeys), [LastPass](https://www.lastpass.com/features/passwordless-authentication), and others.  

### Device Support
Passkeys are widely available across devices such as: 
- Apple Devices: iPhones & iPads (iOS 16+), Mac (macOS 13+)
- Android Devices: Phones and tablets (Android 9+)
- Windows (10/11/+): Supported on Chrome, Brave, Edge, and Firefox browsers
- Linux: Supported on Chrome, Firefox, Edge, and Brave browsers

For a comprehensive list of supported systems, please visit [passkeys.dev/device-support](https://passkeys.dev/device-support/)
